<!DOCTYPE html><html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no" />
  <title>æˆèªä¿„ç¾…æ–¯æ–¹å¡Š</title>
  <style>
    :root {
      --board-bg: #111;
      --cell-size: 40px; /* æœƒåœ¨è…³æœ¬ä¸­æ ¹æ“šè¦–çª—å‹•æ…‹è¦†å¯« */
      --block-bg: #f0c040;
      --block-color: #000;
    }
    *{box-sizing:border-box;margin:0;padding:0;font-family:"Noto Sans TC",sans-serif;user-select:none;-webkit-user-select:none;touch-action:none}
    body{display:flex;justify-content:center;align-items:center;height:100vh;background:#222;color:#fff;overflow:hidden}
    #game{position:relative}
    #board{position:relative;background:var(--board-bg);touch-action:none}
    .block{position:absolute;width:var(--cell-size);height:var(--cell-size);background:var(--block-bg);border-radius:4px;display:flex;justify-content:center;align-items:center;font-size:calc(var(--cell-size)*0.6);font-weight:bold;color:var(--block-color);box-shadow:0 0 4px rgba(0,0,0,.5)}
    #score{margin-top:8px;text-align:center;font-size:1.2rem}
    #overlay{position:absolute;inset:0;background:rgba(0,0,0,.8);display:flex;flex-direction:column;justify-content:center;align-items:center;gap:16px;z-index:10;backdrop-filter:blur(4px)}
    #overlay.hidden{display:none}
    #message{font-size:1.5rem;text-align:center;line-height:1.4}
    button{padding:8px 16px;font-size:1rem;border:none;border-radius:6px;cursor:pointer;background:#f0c040;color:#000}
    .ctrls{margin-top:12px;display:flex;justify-content:center;gap:12px}
  </style>
</head>
<body>
  <div id="game">
    <div id="board"></div>
    <div id="score">å¾—åˆ†ï¼š0 / 20</div>
    <div class="ctrls">
      <button id="leftBtn">â—€ï¸</button>
      <button id="downBtn">â–¼</button>
      <button id="rightBtn">â–¶ï¸</button>
    </div>
    <div id="overlay" class="hidden">
      <div id="message"></div>
      <button id="restartBtn">é‡æ–°é–‹å§‹</button>
      <button id="endBtn">çµæŸéŠæˆ²</button>
    </div>
  </div><script>
(() => {
  /* ========= éŠæˆ²è¨­å®š ========= */
  const COLS = 10;
  const ROWS = 20;
  const TICK_MS = 500; // ä¸‹è½é€Ÿåº¦
  const MAX_SCORE = 20;
  const idioms = [
    "ç•«è›‡æ·»è¶³","äº¡ç¾Šè£œç‰¢","å°ç‰›å½ˆç´","å®ˆæ ªå¾…å…”","æ©è€³ç›œéˆ´","æŒ‡é¹¿ç‚ºé¦¬",
    "åˆ»èˆŸæ±‚åŠ","ç›²äººæ‘¸è±¡","äº•åº•ä¹‹è›™","è‰æœ¨çš†å…µ","ç´™ä¸Šè«‡å…µ","è² èŠè«‹ç½ª",
    "è‡ªç›¸çŸ›ç›¾","ç•«é¾é»ç›","æ¯å¼“è›‡å½±","å››æµ·ç‚ºå®¶","ç™¾ç™¼ç™¾ä¸­","ä¸€å¸†é¢¨é †",
    "é †æ‰‹ç‰½ç¾Š","è‡¥è–ªå˜—è†½"
  ];
  const boardEl = document.getElementById('board');
  const scoreEl = document.getElementById('score');
  const overlayEl = document.getElementById('overlay');
  const msgEl = document.getElementById('message');
  const restartBtn = document.getElementById('restartBtn');
  const endBtn = document.getElementById('endBtn');
  const leftBtn = document.getElementById('leftBtn');
  const rightBtn = document.getElementById('rightBtn');
  const downBtn = document.getElementById('downBtn');

  let cellSize;
  let matrix;
  let falling = null;
  let timer = null;
  let score = 0;
  const completed = new Set();
  let charQueue = [];

  function resize() {
    cellSize = Math.floor(Math.min(window.innerWidth / (COLS + 2), window.innerHeight / (ROWS + 4)));
    document.documentElement.style.setProperty('--cell-size', cellSize + 'px');
    boardEl.style.width = `${COLS * cellSize}px`;
    boardEl.style.height = `${ROWS * cellSize}px`;
  }

  window.addEventListener('resize', resize);
  resize();

  /* ========= å·¥å…· ========= */
  const rand = arr => arr[Math.floor(Math.random() * arr.length)];
  function shuffle(arr) {
    const a = [...arr];
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  /* ========= éŠæˆ²é‚è¼¯ ========= */
  function initMatrix() {
    matrix = Array.from({ length: ROWS }, () => Array(COLS).fill(null));
  }

  function createBlock(char) {
    const el = document.createElement('div');
    el.className = 'block';
    el.textContent = char;
    boardEl.appendChild(el);
    return el;
  }

  function spawnPiece() {
    if (charQueue.length === 0) {
      const remaining = idioms.filter(i => !completed.has(i));
      if (remaining.length === 0) return; // å·²å®Œæˆæ‰€æœ‰
      charQueue = shuffle(remaining[0].split(''));
    }
    const ch = charQueue.pop();
    const col = Math.floor(COLS / 2);
    const row = -1; // å¾ç‰ˆé¢å¤–é–‹å§‹
    const el = createBlock(ch);
    falling = { ch, row, col, el };
    positionEl(el, row, col);
    makeDraggable(falling);
    if (collision(row + 1, col)) {
      gameOver();
    }
  }

  function positionEl(el, row, col) {
    el.style.top = `${row * cellSize}px`;
    el.style.left = `${col * cellSize}px`;
  }

  function collision(newRow, col) {
    return newRow >= ROWS || (newRow >=0 && matrix[newRow][col]);
  }

  function lockPiece() {
    const r = falling.row;
    const c = falling.col;
    if (r >= 0) {
      matrix[r][c] = falling;
    } else {
      gameOver();
      return;
    }
    falling = null;
    clearLines();
    spawnPiece();
  }

  function clearLines() {
    let anyCleared = false;
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c <= COLS - 4; c++) {
        const cells = [matrix[r][c], matrix[r][c + 1], matrix[r][c + 2], matrix[r][c + 3]];
        if (cells.every(cell => cell)) {
          const word = cells.map(cell => cell.ch).join('');
          if (idioms.includes(word) && !completed.has(word)) {
            // æ¸…é™¤æ­¤å››æ ¼
            cells.forEach(cell => {
              boardEl.removeChild(cell.el);
              matrix[cell.row][cell.col] = null;
            });
            completed.add(word);
            score++;
            updateScore();
            anyCleared = true;
          }
        }
      }
    }
    if (anyCleared) {
      applyGravity();
      if (score >= MAX_SCORE) {
        win();
      }
    }
  }

  function applyGravity() {
    for (let c = 0; c < COLS; c++) {
      for (let r = ROWS - 2; r >= 0; r--) {
        if (matrix[r][c]) {
          let nr = r;
          while (!collision(nr + 1, c)) nr++;
          if (nr !== r) {
            const blk = matrix[r][c];
            matrix[r][c] = null;
            matrix[nr][c] = blk;
            blk.row = nr;
            blk.col = c;
            positionEl(blk.el, nr, c);
          }
        }
      }
    }
  }

  function updateScore() {
    scoreEl.textContent = `å¾—åˆ†ï¼š${score} / ${MAX_SCORE}`;
  }

  function tick() {
    if (!falling) return;
    const newRow = falling.row + 1;
    if (!collision(newRow, falling.col)) {
      falling.row = newRow;
      positionEl(falling.el, falling.row, falling.col);
    } else {
      lockPiece();
    }
  }

  /* ========= æ‹–æ‹‰äº‹ä»¶ ========= */
  function makeDraggable(piece) {
    let startX = 0;
    let startCol = 0;
    const el = piece.el;
    el.onpointerdown = e => {
      e.preventDefault();
      startX = e.clientX;
      startCol = piece.col;
      el.setPointerCapture(e.pointerId);
    };
    el.onpointermove = e => {
      if (e.pressure === 0) return; // æœªæŒ‰ä¸‹
      const dx = e.clientX - startX;
      const colOffset = Math.round(dx / cellSize);
      const targetCol = Math.min(Math.max(startCol + colOffset, 0), COLS - 1);
      if (!collision(piece.row, targetCol)) {
        piece.col = targetCol;
        positionEl(el, piece.row, piece.col);
      }
    };
    el.onpointerup = e => {
      el.releasePointerCapture(e.pointerId);
    };
  }

  /* ========= éµç›¤èˆ‡æŒ‰éˆ•æ§åˆ¶ ========= */
  function move(deltaCol) {
    if (!falling) return;
    const target = Math.min(Math.max(falling.col + deltaCol, 0), COLS - 1);
    if (!collision(falling.row, target)) {
      falling.col = target;
      positionEl(falling.el, falling.row, falling.col);
    }
  }
  function softDrop() {
    if (!falling) return;
    while (!collision(falling.row + 1, falling.col)) {
      falling.row++;
    }
    positionEl(falling.el, falling.row, falling.col);
    lockPiece();
  }

  document.addEventListener('keydown', e => {
    if (overlayEl.classList.contains('hidden')) {
      if (e.key === 'ArrowLeft') move(-1);
      else if (e.key === 'ArrowRight') move(1);
      else if (e.key === 'ArrowDown') softDrop();
    }
  });
  leftBtn.addEventListener('click', () => move(-1));
  rightBtn.addEventListener('click', () => move(1));
  downBtn.addEventListener('click', softDrop);

  /* ========= éŠæˆ²çµæŸ/å‹åˆ© ========= */
  function gameOver() {
    stop();
    msgEl.innerHTML = 'Game Over!<br/>å¾—åˆ†ï¼š' + score;
    overlayEl.classList.remove('hidden');
  }
  function win() {
    stop();
    msgEl.innerHTML = 'ğŸ†<br/>æ­å–œä½ å–å¾—æ»¿åˆ†ï¼';
    overlayEl.classList.remove('hidden');
  }
  function stop() {
    clearInterval(timer);
    timer = null;
  }

  restartBtn.addEventListener('click', start);
  endBtn.addEventListener('click', () => {
    overlayEl.innerHTML = '<div style="font-size:2rem">è¬è¬éŠç©ï¼</div>';
  });

  /* ========= é–‹å§‹éŠæˆ² ========= */
  function resetBoard() {
    boardEl.innerHTML = '';
    completed.clear();
    charQueue = [];
  }
  function start() {
    overlayEl.classList.add('hidden');
    resetBoard();
    initMatrix();
    score = 0;
    updateScore();
    falling = null;
    spawnPiece();
    if (!timer) timer = setInterval(tick, TICK_MS);
  }
  start();
})();
</script></body>
</html>
