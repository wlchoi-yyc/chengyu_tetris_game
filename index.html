<!DOCTYPE html><html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>成語俄羅斯方塊遊戲</title>
  <script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js"></script>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Noto Sans TC", sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      background: #f0f4f8;
      height: 100vh;
      overflow: hidden;
      user-select: none;
      -webkit-user-select: none;
    }
    #scoreBoard { margin-top: .5rem; font-size: 1.2rem; font-weight: 700; }
    #gameBoard {
      position: relative;
      width: 100%;
      max-width: 480px;
      height: 70vh;
      background: #fff;
      border: 3px solid #444;
      border-radius: 8px;
      overflow: hidden;
    }
    .block {
      position: absolute;
      width: 56px;
      height: 56px;
      background: #8bc34a;
      color: #fff;
      border: 2px solid #558b2f;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      font-weight: 700;
      touch-action: none;
    }
    .stacked { background: #4caf50; }
    #slotContainer {
      position: absolute;
      bottom: 8px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 6px;
    }
    .slot {
      width: 56px;
      height: 56px;
      background: #e0e0e0;
      border: 2px dashed #9e9e9e;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .slot.correct { border-color: #4caf50; }
    .slot.incorrect { border-color: #f44336; }
    #messageOverlay {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,.75);
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-size: 1.8rem;
      font-weight: 700;
      padding: 1rem;
      text-align: center;
      visibility: hidden;
      z-index: 10;
    }
    #messageOverlay button {
      margin: .8rem .4rem 0;
      padding: .6rem 1.4rem;
      border: none;
      border-radius: 4px;
      background: #ffeb3b;
      font-size: 1rem;
      font-weight: 700;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="scoreBoard">分數：0 / 20</div>
  <div id="gameBoard">
    <div id="slotContainer">
      <div class="slot" data-index="0"></div>
      <div class="slot" data-index="1"></div>
      <div class="slot" data-index="2"></div>
      <div class="slot" data-index="3"></div>
    </div>
    <div id="messageOverlay"></div>
  </div><script>
// ---------------------- 遊戲資料 ----------------------
const idioms = [
  "一竅不通","不恥下問","茅塞頓開","發人深省","今非昔比","老生常談","拋磚引玉","拾人牙慧",
  "語無倫次","強詞奪理","一片冰心","大義凜然","出爾反爾","守正不阿","古道熱腸","坐懷不亂",
  "道不拾遺","見義勇為","涓滴歸公","飲水思源"
];

// 可自行增減干擾字
const distractorPool = "天地玄黃宇宙洪荒日月盈昃辰宿列張寒來暑往秋收冬藏閏餘成歲律呂調陽雲騰致雨露結為霜風雨雷電山川草木鳥獸蟲魚".split("");

// ---------------------- 基本參考 ----------------------
const board = document.getElementById('gameBoard');
const slots = Array.from(document.querySelectorAll('.slot'));
const overlay = document.getElementById('messageOverlay');
const scoreBoard = document.getElementById('scoreBoard');

let score = 0;
let usedIdioms = new Set();
let fallIntervals = [];
let spawnInterval;

// ---------------------- 工具函式 ----------------------
const rand = (min,max)=>Math.floor(Math.random()*(max-min+1))+min;
const shuffle = arr => {
  for(let i=arr.length-1;i>0;i--){const j=rand(0,i);[arr[i],arr[j]]=[arr[j],arr[i]];}return arr;
};
const updateScore = ()=>scoreBoard.textContent=`分數：${score} / 20`;

// ---------------------- 遊戲流程 ----------------------
function startGame(){
  spawnBlocks();                      // 先來一組
  spawnInterval = setInterval(spawnBlocks,2000); // 每 2 秒再來一組
}

function spawnBlocks(){
  if(overlay.style.visibility==='visible')return; // 遊戲結束後不再生成

  if(usedIdioms.size===idioms.length) usedIdioms.clear();
  let idiom;
  do{ idiom = idioms[rand(0,idioms.length-1)]; }while(usedIdioms.has(idiom));
  usedIdioms.add(idiom);

  const chars = idiom.split("");
  const distractors=[];
  while(distractors.length<2){
    const c=distractorPool[rand(0,distractorPool.length-1)];
    if(!chars.includes(c)&&!distractors.includes(c)) distractors.push(c);
  }
  const all = shuffle([...chars,...distractors]);

  // 逐字延時掉落，避免同時重疊
  all.forEach((char,idx)=>setTimeout(()=>createFallingBlock(char),idx*300));
}

function createFallingBlock(char){
  const block=document.createElement('div');
  block.className='block';
  block.textContent=char;
  block.dataset.char=char;
  block.style.left=`${rand(0,board.clientWidth-56)}px`;
  block.style.top='-60px';
  board.appendChild(block);
  makeDraggable(block);
  fall(block);
}

function fall(block){
  const id=setInterval(()=>{
    if(block.isDragging){return;}
    const nextTop=block.offsetTop+2;
    // 與底部或其它 stack 碰撞即停止
    if(nextTop+block.offsetHeight >= board.clientHeight - 70){ // 70 ≈ 底部 slotContainer 高度
      settleBlock(block,id);
    }else if([...board.querySelectorAll('.block.stacked')].some(b=>isCollide(block,b,2))){
      settleBlock(block,id);
    }else{
      block.style.top=`${nextTop}px`;
    }
  },16);
  fallIntervals.push(id);
}

function settleBlock(block,id){
  clearInterval(id);
  fallIntervals=fallIntervals.filter(x=>x!==id);
  block.classList.add('stacked');
  checkGameOver();
}

function isCollide(a,b,offset=0){
  if(a===b) return false;
  const r1=a.getBoundingClientRect();
  const r2=b.getBoundingClientRect();
  return r1.left<r2.right && r1.right>r2.left && r1.bottom+offset>r2.top && r1.top<r2.bottom;
}

// ---------------------- 拖放處理 ----------------------
function makeDraggable(el){
  interact(el).draggable({
    listeners:{
      start(event){
        el.isDragging=true;
        // 若方塊起始在 slot 內 => 清空該 slot
        if(el.parentElement.classList.contains('slot')){
          const slot=el.parentElement;
          slot.dataset.char='';
          slot.classList.remove('correct','incorrect');
          board.appendChild(el);
          // 將方塊定位到與 slot 相同位置
          const boardRect=board.getBoundingClientRect();
          const slotRect=slot.getBoundingClientRect();
          el.style.left=`${slotRect.left-boardRect.left}px`;
          el.style.top=`${slotRect.top-boardRect.top}px`;
          el.style.transform='none';
          el.setAttribute('data-x',0);
          el.setAttribute('data-y',0);
        }
      },
      move(event){
        const x=(parseFloat(el.getAttribute('data-x'))||0)+event.dx;
        const y=(parseFloat(el.getAttribute('data-y'))||0)+event.dy;
        el.style.transform=`translate(${x}px,${y}px)`;
        el.setAttribute('data-x',x);
        el.setAttribute('data-y',y);
      },
      end(){ el.isDragging=false; }
    },
    inertia:true
  });
}

// Slot dropzone
interact('.slot').dropzone({
  accept: '.block',
  overlap: 0.55,
  ondropactivate(event){event.target.classList.remove('correct','incorrect');},
  ondrop(event){
    const slot=event.target;
    const block=event.relatedTarget;
    if(slot.firstElementChild){return;} // 已有方塊

    // 清除 block 位移並放入 slot 內
    block.style.transform='none';
    block.setAttribute('data-x',0);
    block.setAttribute('data-y',0);
    block.style.position='relative';
    block.style.left='0';
    block.style.top='0';
    slot.appendChild(block);
    slot.dataset.char=block.dataset.char;
    checkSlots();
  }
});

function checkSlots(){
  const chars = slots.map(s=>s.dataset.char||'').join('');
  if(chars.length!==4) return;
  if(idioms.includes(chars)){
    slots.forEach(s=>s.classList.add('correct'));
    setTimeout(()=>{
      // 清除 slot 與其中的方塊
      slots.forEach(s=>{
        if(s.firstElementChild) s.firstElementChild.remove();
        s.dataset.char='';
        s.classList.remove('correct');
      });
      score++;
      updateScore();
      if(score>=20){
        endGame('🏆 恭喜你取得滿分！');
      }
    },600);
  }else{
    slots.forEach(s=>s.classList.add('incorrect'));
  }
}

function checkGameOver(){
  if([...board.querySelectorAll('.block.stacked')].some(b=>b.offsetTop<0)){
    endGame('Game Over! 字塊堆疊到頂 😢');
  }
}

function clearAllTimers(){
  fallIntervals.forEach(id=>clearInterval(id));
  fallIntervals=[];
  clearInterval(spawnInterval);
}

function endGame(msg){
  clearAllTimers();
  overlay.innerHTML=`${msg}<br/>`;
  const restart=document.createElement('button');
  restart.textContent='重新開始';
  restart.onclick=()=>location.reload();
  const exit=document.createElement('button');
  exit.textContent='結束遊戲';
  exit.onclick=()=>window.close();
  overlay.appendChild(restart);
  overlay.appendChild(exit);
  overlay.style.visibility='visible';
}

updateScore();
startGame();
</script></body>
</html>
