<!DOCTYPE html><html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>成語俄羅斯方塊遊戲</title>
  <script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js"></script>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      font-family: "Noto Sans TC", sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      background: #f0f4f8;
      height: 100vh;
      overflow: hidden;
      user-select: none;
      -webkit-user-select: none;
    }
    #scoreBoard {
      margin-top: 0.5rem;
      font-size: 1.2rem;
      font-weight: 700;
    }
    #gameBoard {
      position: relative;
      width: 100%;
      max-width: 480px;
      height: 70vh;
      background: #ffffff;
      border: 3px solid #444;
      overflow: hidden;
      border-radius: 8px;
    }
    .block {
      position: absolute;
      width: 56px;
      height: 56px;
      background: #8bc34a;
      color: #fff;
      border: 2px solid #558b2f;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      font-weight: 700;
      border-radius: 4px;
      touch-action: none;
    }
    .stacked {
      background: #4caf50;
    }
    #slotContainer {
      position: absolute;
      bottom: 8px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 6px;
    }
    .slot {
      width: 56px;
      height: 56px;
      background: #e0e0e0;
      border: 2px dashed #9e9e9e;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      font-weight: 700;
    }
    .slot.correct {
      border-color: #4caf50;
    }
    .slot.incorrect {
      border-color: #f44336;
    }
    #messageOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.75);
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-size: 1.8rem;
      font-weight: 700;
      padding: 1rem;
      text-align: center;
      z-index: 5;
      visibility: hidden;
    }
    #messageOverlay button {
      margin-top: 1rem;
      padding: 0.6rem 1.2rem;
      font-size: 1rem;
      border: none;
      border-radius: 4px;
      background: #ffeb3b;
      font-weight: 700;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="scoreBoard">分數：0 / 20</div>
  <div id="gameBoard">
    <div id="slotContainer">
      <div class="slot" data-index="0"></div>
      <div class="slot" data-index="1"></div>
      <div class="slot" data-index="2"></div>
      <div class="slot" data-index="3"></div>
    </div>
    <div id="messageOverlay"></div>
  </div>  <script>
    // Idioms and distractor chars
    const idioms = [
      "一竅不通", "不恥下問", "茅塞頓開", "發人深省", "今非昔比", "老生常談", "拋磚引玉", "拾人牙慧",
      "語無倫次", "強詞奪理", "一片冰心", "大義凜然", "出爾反爾", "守正不阿", "古道熱腸", "坐懷不亂",
      "道不拾遺", "見義勇為", "涓滴歸公", "飲水思源"
    ];

    const distractorPool = "天地玄黃宇宙洪荒日月盈昃辰宿列張寒來暑往秋收冬藏閏餘成歲律呂調陽雲騰致雨露結為霜".split("");

    const board = document.getElementById("gameBoard");
    const scoreBoard = document.getElementById("scoreBoard");
    const overlay = document.getElementById("messageOverlay");
    const slotContainer = document.getElementById("slotContainer");
    const slots = [...document.querySelectorAll(".slot")];

    let score = 0;
    let usedIdioms = new Set();
    let activeBlocks = [];
    let gameIntervals = [];

    // Helpers
    function rand(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function resetSlots() {
      slots.forEach((slot) => {
        slot.textContent = "";
        slot.dataset.char = "";
        slot.classList.remove("correct", "incorrect");
      });
    }

    function updateScore() {
      scoreBoard.textContent = `分數：${score} / 20`;
    }

    function endGame(message) {
      clearAllIntervals();
      overlay.innerHTML = `${message}<br />`;
      const btnGroup = document.createElement("div");
      const restartBtn = document.createElement("button");
      restartBtn.textContent = "重新開始";
      restartBtn.onclick = () => location.reload();
      const exitBtn = document.createElement("button");
      exitBtn.textContent = "結束遊戲";
      exitBtn.onclick = () => window.close();
      btnGroup.appendChild(restartBtn);
      btnGroup.appendChild(exitBtn);
      overlay.appendChild(btnGroup);
      overlay.style.visibility = "visible";
    }

    function clearAllIntervals() {
      gameIntervals.forEach((id) => clearInterval(id));
      gameIntervals = [];
    }

    // Collision detection for stacking
    function willCollide(block) {
      const nextY = block.offsetTop + 2; // fall speed
      if (nextY + block.offsetHeight >= board.offsetHeight - slotContainer.offsetHeight) return true;
      return Array.from(board.children).some((el) => {
        if (!el.classList.contains("block") || el === block || !el.classList.contains("stacked")) return false;
        const rect1 = block.getBoundingClientRect();
        const rect2 = el.getBoundingClientRect();
        return (
          rect1.left < rect2.right &&
          rect1.right > rect2.left &&
          rect1.bottom + 2 >= rect2.top &&
          rect1.bottom <= rect2.top + 6
        );
      });
    }

    function spawnBlocks() {
      if (usedIdioms.size === idioms.length) usedIdioms.clear();
      let idiom;
      do {
        idiom = idioms[rand(0, idioms.length - 1)];
      } while (usedIdioms.has(idiom));
      usedIdioms.add(idiom);

      const chars = idiom.split("");
      const distractors = [];
      while (distractors.length < 2) {
        const c = distractorPool[rand(0, distractorPool.length - 1)];
        if (!chars.includes(c) && distractors.indexOf(c) === -1) distractors.push(c);
      }

      const allChars = shuffle([...chars, ...distractors]);

      allChars.forEach((char) => {
        const block = document.createElement("div");
        block.className = "block";
        block.textContent = char;
        block.dataset.char = char;
        block.style.left = `${rand(0, board.offsetWidth - 56)}px`;
        block.style.top = "-60px";
        board.appendChild(block);
        activeBlocks.push(block);
        fall(block);
        makeDraggable(block);
      });
    }

    function fall(block) {
      const intervalId = setInterval(() => {
        if (!block.isDragging) {
          if (!willCollide(block)) {
            block.style.top = `${block.offsetTop + 2}px`;
          } else {
            block.classList.add("stacked");
            clearInterval(intervalId);
            gameIntervals = gameIntervals.filter((id) => id !== intervalId);
            checkGameOver();
            // Remove reference from activeBlocks
            activeBlocks = activeBlocks.filter((b) => b !== block);
          }
        }
      }, 16);
      gameIntervals.push(intervalId);
    }

    function checkGameOver() {
      const stacked = [...board.querySelectorAll(".block.stacked")];
      if (stacked.some((b) => b.offsetTop < 0)) {
        endGame("Game Over! 字塊堆疊到頂\uD83D\uDE1E");
      } else if (stacked.length > 200) {
        // Fallback safety limit
        endGame("Game Over! 字塊過多\uD83D\uDE1E");
      }
    }

    function makeDraggable(element) {
      interact(element)
        .draggable({
          listeners: {
            start() {
              element.isDragging = true;
            },
            move(event) {
              const x = (parseFloat(element.getAttribute("data-x")) || 0) + event.dx;
              const y = (parseFloat(element.getAttribute("data-y")) || 0) + event.dy;
              element.style.transform = `translate(${x}px, ${y}px)`;
              element.setAttribute("data-x", x);
              element.setAttribute("data-y", y);
            },
            end() {
              element.isDragging = false;
            },
          },
          inertia: true,
        });
    }

    // Dropzones for slots
    interact(".slot").dropzone({
      accept: ".block",
      overlap: 0.55,
      ondropactivate(event) {
        event.target.classList.remove("correct", "incorrect");
      },
      ondrop(event) {
        const slot = event.target;
        if (slot.dataset.char) return; // already filled
        const block = event.relatedTarget;
        slot.textContent = block.dataset.char;
        slot.dataset.char = block.dataset.char;
        block.remove();
        checkSlots();
      },
    });

    function checkSlots() {
      const chars = slots.map((s) => s.dataset.char || "").join("");
      if (chars.length === 4) {
        if (idioms.includes(chars)) {
          slots.forEach((s) => s.classList.add("correct"));
          setTimeout(() => {
            resetSlots();
            score += 1;
            updateScore();
            if (score >= 20) {
              endGame("\uD83C\uDFC6 恭喜你取得滿分！\uD83C\uDFC6");
            } else {
              spawnBlocks();
            }
          }, 600);
        } else {
          slots.forEach((s) => s.classList.add("incorrect"));
        }
      }
    }

    // Start game
    updateScore();
    spawnBlocks();
  </script></body>
</html>
